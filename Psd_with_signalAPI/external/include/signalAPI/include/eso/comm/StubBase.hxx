/*
      Copyright e.solutions GmbH
    All rights reserved
    Authors:
        Stefan Bittner
*/

#ifndef COMM_STUBBASE_HXX
#define COMM_STUBBASE_HXX

// stub base
// delegates to the implementation

#include <ipl_config.h>
#include <comm/comm_dso.h>
#include <comm/commtypes.hxx>
#include <comm/CallEvent.hxx>
#include <comm/AtomicBool.hxx>
#include <comm/Proxy.hxx>
#include <util/UInt32Tag.hxx>

#include <memory>

namespace comm {

    class Core;
    class ServiceInfo;
    class CallEventImpl;
    class Connection;
    using ConnectionPtr = std::shared_ptr<Connection>;

    /**
    \brief    baseclass for a stub in the comm-framework. All stubs are derived from this class.

        Specific stub implementations are generated by the IDL-Code-Generation.
    **/
    class COMM_EXPORT StubBase {
        public:

        StubBase () IPL_NOEXCEPT;
        StubBase ( const comm::ConnectionPtr& conn
                    ,comm::InstanceID::Handle_t reply_handle
                    ,const ProxyStubID& psid) IPL_NOEXCEPT;
        virtual ~StubBase () IPL_NOEXCEPT;

        /**
        \brief    set the pointer to the instance, which implements this interface.
        **/
        virtual void setDelegate(void*) = 0;

        /**
        \brief    Processes messages dispatched to the stub.

                This methid is called for each message dispatched to the stub. It must
                be implemented by the derived class
        \param
                mid method ID
        \param
                payload the data container with the payload pertaining to the method.
        \return
                true on error, false otherwise.
        \errorindicator
                via return code
        \errors
                comm::Error
        **/
        virtual bool process (comm::MethodID mid, const ICallPayload& payload
                                ,const CallContext& ctx) IPL_NOEXCEPT = 0;

        /**
            \brief Returns if a certain method id is associated with a call id
        */
        virtual bool calls(comm::MethodID mid, const comm::CallEvent::CallID& id) const
                            IPL_NOEXCEPT {return false;}

        /**
            \brief Informs the the stub about clients connecting/disconnecting
            \param connects true, if the client connected, false if it disconnected
            \param clients number of connected clients after the change
        */
        virtual void clientChange( bool connects, size_t clients
                                ,const CallContext& ctx) IPL_NOEXCEPT {
            // The default implementation is intentionally empty.
        }


        /**
        \brief Returns the reply proxy or an invalid one if it has none.
        **/
        virtual comm::Proxy getReplyProxy() IPL_NOEXCEPT { return Proxy(); }

        const comm::ConnectionPtr& getConnection() const IPL_NOEXCEPT { return m_conn; }

        comm::ProxyID getPID() const IPL_NOEXCEPT { return m_psid.pid; }
        comm::StubID getSID() const IPL_NOEXCEPT { return m_psid.sid; }

        bool isConnected() const IPL_NOEXCEPT { return m_connected.isSet(); }

        protected:
            ConnectionPtr                   m_conn;
            InstanceID::Handle_t            m_handle{0u};
            ProxyStubID                     m_psid;
            uint32_t                        m_seq{0};       // sequence number of the lase call
                                                            // received. updated before the call
                                                            // into the service
            util::UInt32Tag                 m_serializerTag{util::serializer::k_UNDEFINED};

        private:
            AtomicBool                      m_connected;
            void updatePID(ProxyID pid)     { m_psid.pid = pid; }
            void setConnected()             { (void)m_connected.set(); }
            void*                           m_impl{nullptr};         // future extensions
            void updateSerializerTag(util::UInt32Tag t) IPL_NOEXCEPT;

            friend class Core;
            friend class ServiceInfo;
            friend class CallEventImpl;
    };

    using StubBasePtr = std::shared_ptr<StubBase>;
}

#endif // COMM_STUBBASE_HXX

